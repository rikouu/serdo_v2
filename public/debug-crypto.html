<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Serdo åŠ å¯†è¯Šæ–­å·¥å…·</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      color: #333;
      border-bottom: 3px solid #4CAF50;
      padding-bottom: 10px;
    }
    .section {
      background: white;
      padding: 20px;
      margin: 20px 0;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h2 {
      color: #4CAF50;
      margin-top: 0;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 10px;
    }
    button:hover {
      background: #45a049;
    }
    button.secondary {
      background: #2196F3;
    }
    button.secondary:hover {
      background: #0b7dda;
    }
    button.danger {
      background: #f44336;
    }
    button.danger:hover {
      background: #da190b;
    }
    input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-right: 10px;
      font-size: 14px;
    }
    pre {
      background: #f4f4f4;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      border-left: 4px solid #4CAF50;
    }
    .success {
      color: #4CAF50;
      font-weight: bold;
    }
    .error {
      color: #f44336;
      font-weight: bold;
    }
    .warning {
      color: #ff9800;
      font-weight: bold;
    }
    .status {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 3px;
      font-size: 12px;
      font-weight: bold;
      margin-left: 10px;
    }
    .status.ok {
      background: #4CAF50;
      color: white;
    }
    .status.error {
      background: #f44336;
      color: white;
    }
    .status.warning {
      background: #ff9800;
      color: white;
    }
  </style>
</head>
<body>
  <h1>ğŸ”§ Serdo åŠ å¯†/è§£å¯†è¯Šæ–­å·¥å…·</h1>
  
  <div class="section">
    <h2>1. æ£€æŸ¥å­˜å‚¨çŠ¶æ€</h2>
    <button onclick="checkStorage()">æ£€æŸ¥ Storage</button>
    <button class="secondary" onclick="clearStorage()">æ¸…é™¤ Storage</button>
    <button class="danger" onclick="generateNewKey()">ç”Ÿæˆæ–°å¯†é’¥</button>
    <pre id="storageResult">ç‚¹å‡»"æ£€æŸ¥ Storage"æŸ¥çœ‹å½“å‰çŠ¶æ€</pre>
  </div>
  
  <div class="section">
    <h2>2. æµ‹è¯•æµè§ˆå™¨åŠ å¯†/è§£å¯†</h2>
    <input type="text" id="testPassword" placeholder="è¾“å…¥æµ‹è¯•å¯†ç " value="test123">
    <button onclick="testEncryptDecrypt()">æµ‹è¯•åŠ å¯†è§£å¯†</button>
    <pre id="encryptDecryptResult">ç‚¹å‡»"æµ‹è¯•åŠ å¯†è§£å¯†"å¼€å§‹æµ‹è¯•</pre>
  </div>
  
  <div class="section">
    <h2>3. æµ‹è¯•åç«¯ API</h2>
    <input type="text" id="apiBase" placeholder="API åœ°å€" value="http://localhost:4000/api/v1" style="width: 300px;">
    <button onclick="testRevealApi()">æµ‹è¯• Reveal API</button>
    <pre id="apiTestResult">ç‚¹å‡»"æµ‹è¯• Reveal API"å¼€å§‹æµ‹è¯•</pre>
  </div>
  
  <div class="section">
    <h2>4. æµ‹è¯•å®Œæ•´æµç¨‹</h2>
    <p>è¿™ä¸ªæµ‹è¯•ä¼šæ¨¡æ‹Ÿå®Œæ•´çš„ä¿å­˜å’ŒæŸ¥çœ‹å¯†ç æµç¨‹ï¼š</p>
    <input type="text" id="fullTestPassword" placeholder="è¾“å…¥æµ‹è¯•å¯†ç " value="mySecretPassword123">
    <button onclick="testFullFlow()">æµ‹è¯•å®Œæ•´æµç¨‹</button>
    <button class="secondary" onclick="testFullFlowWithRefresh()">æµ‹è¯•ï¼ˆå«åˆ·æ–°ï¼‰</button>
    <pre id="fullTestResult">ç‚¹å‡»"æµ‹è¯•å®Œæ•´æµç¨‹"å¼€å§‹æµ‹è¯•</pre>
  </div>
  
  <div class="section">
    <h2>5. è¯Šæ–­ç»“æœæ‘˜è¦</h2>
    <button onclick="runAllDiagnostics()">è¿è¡Œå®Œæ•´è¯Šæ–­</button>
    <pre id="diagnosticsSummary">ç‚¹å‡»"è¿è¡Œå®Œæ•´è¯Šæ–­"è·å–å®Œæ•´æŠ¥å‘Š</pre>
  </div>

  <script>
    // Base64 ç¼–ç /è§£ç è¾…åŠ©å‡½æ•°
    function bytesToB64(buf) {
      const u8 = new Uint8Array(buf);
      let s = '';
      for (let i = 0; i < u8.length; i++) s += String.fromCharCode(u8[i]);
      return btoa(s);
    }

    function b64ToBytes(b64) {
      const s = atob(b64);
      const u8 = new Uint8Array(s.length);
      for (let i = 0; i < s.length; i++) u8[i] = s.charCodeAt(i);
      return u8;
    }

    // 1. æ£€æŸ¥å­˜å‚¨
    function checkStorage() {
      try {
        const revealKey = sessionStorage.getItem('infravault_reveal_key');
        const token = localStorage.getItem('infravault_token');
        
        let result = 'ğŸ“Š å­˜å‚¨çŠ¶æ€æ£€æŸ¥ç»“æœ:\n\n';
        
        // Reveal Key æ£€æŸ¥
        if (revealKey) {
          const keyBytes = b64ToBytes(revealKey);
          result += `âœ… Reveal Key: å­˜åœ¨\n`;
          result += `   é•¿åº¦: ${revealKey.length} å­—ç¬¦\n`;
          result += `   è§£ç å: ${keyBytes.length} å­—èŠ‚ ${keyBytes.length === 32 ? 'âœ… æ­£ç¡®' : 'âŒ é”™è¯¯ï¼ˆåº”è¯¥æ˜¯32å­—èŠ‚ï¼‰'}\n`;
          result += `   é¢„è§ˆ: ${revealKey.slice(0, 20)}...\n\n`;
        } else {
          result += `âŒ Reveal Key: ä¸å­˜åœ¨\n`;
          result += `   è¿™æ„å‘³ç€éœ€è¦ç”Ÿæˆæ–°å¯†é’¥\n\n`;
        }
        
        // Token æ£€æŸ¥
        if (token) {
          try {
            const parts = token.split('.');
            if (parts.length === 3) {
              const payload = JSON.parse(atob(parts[1]));
              result += `âœ… Token: å­˜åœ¨\n`;
              result += `   é•¿åº¦: ${token.length} å­—ç¬¦\n`;
              result += `   é¢„è§ˆ: ${token.slice(0, 20)}...\n`;
              result += `   Payload: ${JSON.stringify(payload, null, 2)}\n\n`;
            } else {
              result += `âš ï¸ Token: å­˜åœ¨ä½†æ ¼å¼å¼‚å¸¸\n`;
              result += `   é¢„è§ˆ: ${token.slice(0, 50)}...\n\n`;
            }
          } catch (e) {
            result += `âš ï¸ Token: å­˜åœ¨ä½†æ— æ³•è§£æ\n`;
            result += `   é”™è¯¯: ${e.message}\n\n`;
          }
        } else {
          result += `âŒ Token: ä¸å­˜åœ¨ï¼ˆæœªç™»å½•ï¼‰\n\n`;
        }
        
        // æµè§ˆå™¨å…¼å®¹æ€§æ£€æŸ¥
        result += 'ğŸŒ æµè§ˆå™¨å…¼å®¹æ€§:\n';
        result += `   sessionStorage: ${typeof sessionStorage !== 'undefined' ? 'âœ… æ”¯æŒ' : 'âŒ ä¸æ”¯æŒ'}\n`;
        result += `   localStorage: ${typeof localStorage !== 'undefined' ? 'âœ… æ”¯æŒ' : 'âŒ ä¸æ”¯æŒ'}\n`;
        result += `   crypto.subtle: ${typeof crypto?.subtle !== 'undefined' ? 'âœ… æ”¯æŒ' : 'âŒ ä¸æ”¯æŒ'}\n`;
        result += `   crypto.getRandomValues: ${typeof crypto?.getRandomValues !== 'undefined' ? 'âœ… æ”¯æŒ' : 'âŒ ä¸æ”¯æŒ'}\n`;
        
        document.getElementById('storageResult').textContent = result;
      } catch (error) {
        document.getElementById('storageResult').textContent = `âŒ é”™è¯¯: ${error.message}\n\n${error.stack}`;
      }
    }

    function clearStorage() {
      if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰å­˜å‚¨çš„æ•°æ®å—ï¼Ÿè¿™å°†é€€å‡ºç™»å½•çŠ¶æ€ã€‚')) {
        sessionStorage.clear();
        localStorage.clear();
        alert('âœ… å·²æ¸…é™¤æ‰€æœ‰å­˜å‚¨æ•°æ®');
        checkStorage();
      }
    }

    function generateNewKey() {
      try {
        const keyBuffer = crypto.getRandomValues(new Uint8Array(32));
        const keyB64 = bytesToB64(keyBuffer.buffer);
        sessionStorage.setItem('infravault_reveal_key', keyB64);
        alert('âœ… å·²ç”Ÿæˆæ–°çš„ Reveal Key');
        checkStorage();
      } catch (error) {
        alert('âŒ ç”Ÿæˆå¯†é’¥å¤±è´¥: ' + error.message);
      }
    }

    // 2. æµ‹è¯•æµè§ˆå™¨åŠ å¯†è§£å¯†
    async function testEncryptDecrypt() {
      const password = document.getElementById('testPassword').value;
      
      if (!password) {
        document.getElementById('encryptDecryptResult').textContent = 'âŒ è¯·è¾“å…¥æµ‹è¯•å¯†ç ';
        return;
      }
      
      try {
        let result = 'ğŸ” åŠ å¯†/è§£å¯†æµ‹è¯•ç»“æœ:\n\n';
        result += `åŸå§‹å¯†ç : "${password}"\n\n`;
        
        // ç”Ÿæˆæµ‹è¯•å¯†é’¥ï¼ˆ32å­—èŠ‚ï¼‰
        const keyBuffer = crypto.getRandomValues(new Uint8Array(32));
        const keyB64 = bytesToB64(keyBuffer.buffer);
        result += `å¯†é’¥ç”Ÿæˆ: âœ…\n`;
        result += `  é•¿åº¦: ${keyBuffer.length} å­—èŠ‚\n`;
        result += `  Base64: ${keyB64.slice(0, 30)}...\n\n`;
        
        // åŠ å¯†
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const cryptoKey = await crypto.subtle.importKey(
          'raw',
          keyBuffer,
          { name: 'AES-GCM' },
          false,
          ['encrypt', 'decrypt']
        );
        
        const enc = new TextEncoder();
        const encoded = enc.encode(password);
        const encrypted = await crypto.subtle.encrypt(
          { name: 'AES-GCM', iv },
          cryptoKey,
          encoded
        );
        
        const encArray = new Uint8Array(encrypted);
        const dataArray = encArray.slice(0, -16);
        const tagArray = encArray.slice(-16);
        
        const ivB64 = bytesToB64(iv.buffer);
        const tagB64 = bytesToB64(tagArray.buffer);
        const dataB64 = bytesToB64(dataArray.buffer);
        
        result += `åŠ å¯†å®Œæˆ: âœ…\n`;
        result += `  IV: ${ivB64.slice(0, 20)}... (${iv.length} bytes)\n`;
        result += `  Tag: ${tagB64.slice(0, 20)}... (${tagArray.length} bytes)\n`;
        result += `  Data: ${dataB64.slice(0, 20)}... (${dataArray.length} bytes)\n\n`;
        
        // è§£å¯†
        const combined = new Uint8Array([...dataArray, ...tagArray]);
        const decrypted = await crypto.subtle.decrypt(
          { name: 'AES-GCM', iv },
          cryptoKey,
          combined
        );
        
        const dec = new TextDecoder();
        const decryptedText = dec.decode(decrypted);
        
        result += `è§£å¯†å®Œæˆ: âœ…\n`;
        result += `  è§£å¯†ç»“æœ: "${decryptedText}"\n`;
        result += `  åŒ¹é…ç»“æœ: ${password === decryptedText ? 'âœ… æˆåŠŸ' : 'âŒ å¤±è´¥'}\n\n`;
        
        if (password === decryptedText) {
          result += 'ğŸ‰ æµ‹è¯•é€šè¿‡ï¼æµè§ˆå™¨åŠ å¯†/è§£å¯†åŠŸèƒ½æ­£å¸¸ã€‚\n';
        } else {
          result += 'âŒ æµ‹è¯•å¤±è´¥ï¼åŸå§‹å¯†ç å’Œè§£å¯†ç»“æœä¸åŒ¹é…ã€‚\n';
        }
        
        document.getElementById('encryptDecryptResult').textContent = result;
        
      } catch (error) {
        document.getElementById('encryptDecryptResult').textContent = 
          `âŒ æµ‹è¯•å¤±è´¥:\n\n${error.message}\n\n${error.stack}`;
      }
    }

    // 3. æµ‹è¯•åç«¯ API
    async function testRevealApi() {
      const apiBase = document.getElementById('apiBase').value;
      const token = localStorage.getItem('infravault_token');
      let revealKey = sessionStorage.getItem('infravault_reveal_key');
      
      let result = 'ğŸ”Œ åç«¯ API æµ‹è¯•ç»“æœ:\n\n';
      
      // æ£€æŸ¥ token
      if (!token) {
        result += 'âŒ æœªç™»å½•ï¼ˆæ²¡æœ‰ tokenï¼‰\n';
        result += '   è¯·å…ˆç™»å½•ç³»ç»Ÿï¼Œç„¶åå†è¿è¡Œæ­¤æµ‹è¯•ã€‚\n';
        document.getElementById('apiTestResult').textContent = result;
        return;
      }
      
      result += `âœ… Token: å­˜åœ¨\n`;
      result += `   é¢„è§ˆ: ${token.slice(0, 20)}...\n\n`;
      
      // æ£€æŸ¥æˆ–ç”Ÿæˆ reveal key
      if (!revealKey) {
        result += 'âš ï¸ Reveal Key ä¸å­˜åœ¨ï¼Œç”Ÿæˆæ–°å¯†é’¥...\n';
        const keyBuffer = crypto.getRandomValues(new Uint8Array(32));
        revealKey = bytesToB64(keyBuffer.buffer);
        sessionStorage.setItem('infravault_reveal_key', revealKey);
        result += `âœ… å·²ç”Ÿæˆæ–°å¯†é’¥\n`;
      } else {
        result += `âœ… Reveal Key: å­˜åœ¨\n`;
      }
      result += `   é¢„è§ˆ: ${revealKey.slice(0, 20)}...\n\n`;
      
      // æµ‹è¯• /reveal/test ç«¯ç‚¹
      try {
        result += 'æµ‹è¯• /reveal/test ç«¯ç‚¹...\n';
        const response = await fetch(`${apiBase}/reveal/test`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'x-reveal-key': revealKey,
            'Content-Type': 'application/json'
          }
        });
        
        const data = await response.json();
        
        if (response.ok && data.ok) {
          result += `  âœ… çŠ¶æ€: ${response.status}\n`;
          result += `  âœ… å“åº”: ${JSON.stringify(data)}\n\n`;
          result += 'ğŸ‰ åç«¯ API å·¥ä½œæ­£å¸¸ï¼\n';
        } else {
          result += `  âš ï¸ çŠ¶æ€: ${response.status}\n`;
          result += `  âš ï¸ å“åº”: ${JSON.stringify(data)}\n\n`;
          result += 'âš ï¸ åç«¯ API è¿”å›å¼‚å¸¸å“åº”ã€‚\n';
        }
        
      } catch (error) {
        result += `  âŒ é”™è¯¯: ${error.message}\n\n`;
        result += 'âŒ æ— æ³•è¿æ¥åˆ°åç«¯ APIã€‚\n';
        result += '\nå¯èƒ½åŸå› :\n';
        result += '1. åç«¯æœåŠ¡æœªå¯åŠ¨\n';
        result += '2. API åœ°å€é”™è¯¯\n';
        result += '3. CORS è·¨åŸŸé—®é¢˜\n';
        result += `4. ç½‘ç»œè¿æ¥é—®é¢˜\n\n`;
      }
      
      document.getElementById('apiTestResult').textContent = result;
    }

    // 4. æµ‹è¯•å®Œæ•´æµç¨‹
    async function testFullFlow() {
      const password = document.getElementById('fullTestPassword').value;
      const apiBase = document.getElementById('apiBase').value;
      const token = localStorage.getItem('infravault_token');
      
      if (!password) {
        document.getElementById('fullTestResult').textContent = 'âŒ è¯·è¾“å…¥æµ‹è¯•å¯†ç ';
        return;
      }
      
      if (!token) {
        document.getElementById('fullTestResult').textContent = 'âŒ æœªç™»å½•ï¼ˆæ²¡æœ‰ tokenï¼‰\nè¯·å…ˆç™»å½•ç³»ç»Ÿã€‚';
        return;
      }
      
      let result = 'ğŸ”„ å®Œæ•´æµç¨‹æµ‹è¯•:\n\n';
      result += `æµ‹è¯•å¯†ç : "${password}"\n`;
      result += `API åœ°å€: ${apiBase}\n\n`;
      
      try {
        // Step 1: ä¿å­˜å¯†ç 
        result += 'æ­¥éª¤ 1: ä¿å­˜å¯†ç åˆ°åç«¯...\n';
        const saveResponse = await fetch(`${apiBase}/settings`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            whoisApiKey: password,
            whoisApiBaseUrl: 'https://test.com',
            notifications: {
              bark: { enabled: false },
              smtp: { enabled: false },
              preferences: {}
            }
          })
        });
        
        if (!saveResponse.ok) {
          throw new Error(`ä¿å­˜å¤±è´¥: ${saveResponse.status}`);
        }
        
        const saveData = await saveResponse.json();
        result += `  âœ… ä¿å­˜æˆåŠŸ\n`;
        result += `  å“åº”: ${JSON.stringify(saveData).slice(0, 100)}...\n\n`;
        
        // Step 2: æŸ¥çœ‹å¯†ç 
        result += 'æ­¥éª¤ 2: ä»åç«¯æŸ¥çœ‹å¯†ç ...\n';
        let revealKey = sessionStorage.getItem('infravault_reveal_key');
        if (!revealKey) {
          const keyBuffer = crypto.getRandomValues(new Uint8Array(32));
          revealKey = bytesToB64(keyBuffer.buffer);
          sessionStorage.setItem('infravault_reveal_key', revealKey);
          result += `  ç”Ÿæˆæ–°çš„ Reveal Key\n`;
        } else {
          result += `  ä½¿ç”¨å·²æœ‰çš„ Reveal Key\n`;
        }
        
        const revealResponse = await fetch(`${apiBase}/reveal/settings/key`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'x-reveal-key': revealKey
          }
        });
        
        if (!revealResponse.ok) {
          throw new Error(`æŸ¥çœ‹å¤±è´¥: ${revealResponse.status}`);
        }
        
        const revealData = await revealResponse.json();
        result += `  âœ… è·å–åŠ å¯†æ•°æ®æˆåŠŸ\n`;
        
        if (revealData.whoisApiKey) {
          const { iv, tag, data } = revealData.whoisApiKey;
          result += `  IV: ${iv?.slice(0, 20)}...\n`;
          result += `  Tag: ${tag?.slice(0, 20)}...\n`;
          result += `  Data: ${data?.slice(0, 20)}...\n\n`;
          
          // Step 3: è§£å¯†
          result += 'æ­¥éª¤ 3: è§£å¯†å¯†ç ...\n';
          const keyRaw = b64ToBytes(revealKey);
          const ivBytes = b64ToBytes(iv);
          const tagBytes = b64ToBytes(tag);
          const dataBytes = b64ToBytes(data);
          const combined = new Uint8Array([...dataBytes, ...tagBytes]);
          
          const cryptoKey = await crypto.subtle.importKey(
            'raw',
            keyRaw,
            { name: 'AES-GCM' },
            false,
            ['decrypt']
          );
          
          const decrypted = await crypto.subtle.decrypt(
            { name: 'AES-GCM', iv: ivBytes },
            cryptoKey,
            combined
          );
          
          const dec = new TextDecoder();
          const decryptedPassword = dec.decode(decrypted);
          
          result += `  è§£å¯†ç»“æœ: "${decryptedPassword}"\n`;
          result += `  åŒ¹é…æ£€æŸ¥: ${password === decryptedPassword ? 'âœ… æˆåŠŸ' : 'âŒ å¤±è´¥'}\n\n`;
          
          if (password === decryptedPassword) {
            result += 'ğŸ‰ å®Œæ•´æµç¨‹æµ‹è¯•é€šè¿‡ï¼\n';
            result += '\nç³»ç»Ÿå·¥ä½œæ­£å¸¸ï¼š\n';
            result += 'âœ… å¯†ç ä¿å­˜æˆåŠŸ\n';
            result += 'âœ… å¯†ç åŠ å¯†æˆåŠŸ\n';
            result += 'âœ… å¯†ç è§£å¯†æˆåŠŸ\n';
            result += 'âœ… å¯†ç åŒ¹é…æˆåŠŸ\n';
          } else {
            result += 'âŒ å®Œæ•´æµç¨‹æµ‹è¯•å¤±è´¥ï¼\n';
            result += '\né—®é¢˜ï¼šè§£å¯†åçš„å¯†ç ä¸åŸå§‹å¯†ç ä¸åŒ¹é…\n';
            result += `  åŸå§‹: "${password}"\n`;
            result += `  è§£å¯†: "${decryptedPassword}"\n`;
          }
        } else {
          result += '  âš ï¸ åç«¯è¿”å›ç©ºæ•°æ®\n';
          result += `  å“åº”: ${JSON.stringify(revealData)}\n\n`;
          result += 'âš ï¸ å¯èƒ½çš„åŸå› ï¼š\n';
          result += '1. REDACT_MODE æœªè®¾ç½®ä¸º true\n';
          result += '2. åç«¯åŠ å¯†é€»è¾‘æœ‰é—®é¢˜\n';
          result += '3. å¯†ç æœªæ­£ç¡®ä¿å­˜\n';
        }
        
      } catch (error) {
        result += `\nâŒ æµ‹è¯•å¤±è´¥:\n`;
        result += `  é”™è¯¯: ${error.message}\n`;
        result += `  å †æ ˆ: ${error.stack}\n`;
      }
      
      document.getElementById('fullTestResult').textContent = result;
    }

    function testFullFlowWithRefresh() {
      alert('âš ï¸ æ­¤æµ‹è¯•éœ€è¦æ‰‹åŠ¨æ“ä½œï¼š\n\n' +
            '1. å…ˆç‚¹å‡»"æµ‹è¯•å®Œæ•´æµç¨‹"å¹¶ç­‰å¾…å®Œæˆ\n' +
            '2. ç„¶åæŒ‰ F5 åˆ·æ–°é¡µé¢\n' +
            '3. é¡µé¢åŠ è½½åï¼Œå†æ¬¡ç‚¹å‡»"æµ‹è¯•å®Œæ•´æµç¨‹"\n' +
            '4. æ£€æŸ¥å¯†ç æ˜¯å¦èƒ½æ­£ç¡®æ˜¾ç¤º\n\n' +
            'å¦‚æœåˆ·æ–°åä»èƒ½æ­£ç¡®æ˜¾ç¤ºå¯†ç ï¼Œè¯´æ˜ sessionStorage å·¥ä½œæ­£å¸¸ï¼');
    }

    // 5. è¿è¡Œå®Œæ•´è¯Šæ–­
    async function runAllDiagnostics() {
      let summary = 'ğŸ“Š å®Œæ•´è¯Šæ–­æŠ¥å‘Š\n';
      summary += '=' .repeat(60) + '\n\n';
      summary += `ç”Ÿæˆæ—¶é—´: ${new Date().toLocaleString()}\n\n`;
      
      // 1. å­˜å‚¨æ£€æŸ¥
      summary += '1ï¸âƒ£ å­˜å‚¨æ£€æŸ¥:\n';
      const revealKey = sessionStorage.getItem('infravault_reveal_key');
      const token = localStorage.getItem('infravault_token');
      
      if (revealKey) {
        const keyBytes = b64ToBytes(revealKey);
        summary += `   âœ… Reveal Key: å­˜åœ¨ (${keyBytes.length} å­—èŠ‚)\n`;
      } else {
        summary += `   âŒ Reveal Key: ä¸å­˜åœ¨\n`;
      }
      
      if (token) {
        summary += `   âœ… Token: å­˜åœ¨\n`;
      } else {
        summary += `   âŒ Token: ä¸å­˜åœ¨ï¼ˆæœªç™»å½•ï¼‰\n`;
      }
      summary += '\n';
      
      // 2. æµè§ˆå™¨å…¼å®¹æ€§
      summary += '2ï¸âƒ£ æµè§ˆå™¨å…¼å®¹æ€§:\n';
      summary += `   ${typeof sessionStorage !== 'undefined' ? 'âœ…' : 'âŒ'} sessionStorage\n`;
      summary += `   ${typeof localStorage !== 'undefined' ? 'âœ…' : 'âŒ'} localStorage\n`;
      summary += `   ${typeof crypto?.subtle !== 'undefined' ? 'âœ…' : 'âŒ'} crypto.subtle\n`;
      summary += `   ${typeof crypto?.getRandomValues !== 'undefined' ? 'âœ…' : 'âŒ'} crypto.getRandomValues\n`;
      summary += '\n';
      
      // 3. åŠ å¯†æµ‹è¯•
      summary += '3ï¸âƒ£ åŠ å¯†/è§£å¯†æµ‹è¯•:\n';
      try {
        const testPassword = 'test123';
        const keyBuffer = crypto.getRandomValues(new Uint8Array(32));
        const iv = crypto.getRandomValues(new Uint8Array(12));
        
        const cryptoKey = await crypto.subtle.importKey(
          'raw',
          keyBuffer,
          { name: 'AES-GCM' },
          false,
          ['encrypt', 'decrypt']
        );
        
        const enc = new TextEncoder();
        const encoded = enc.encode(testPassword);
        const encrypted = await crypto.subtle.encrypt(
          { name: 'AES-GCM', iv },
          cryptoKey,
          encoded
        );
        
        const encArray = new Uint8Array(encrypted);
        const dataArray = encArray.slice(0, -16);
        const tagArray = encArray.slice(-16);
        const combined = new Uint8Array([...dataArray, ...tagArray]);
        
        const decrypted = await crypto.subtle.decrypt(
          { name: 'AES-GCM', iv },
          cryptoKey,
          combined
        );
        
        const dec = new TextDecoder();
        const decryptedText = dec.decode(decrypted);
        
        if (testPassword === decryptedText) {
          summary += `   âœ… åŠ å¯†/è§£å¯†åŠŸèƒ½æ­£å¸¸\n`;
        } else {
          summary += `   âŒ åŠ å¯†/è§£å¯†åŠŸèƒ½å¼‚å¸¸ï¼ˆå¯†ç ä¸åŒ¹é…ï¼‰\n`;
        }
      } catch (error) {
        summary += `   âŒ åŠ å¯†/è§£å¯†æµ‹è¯•å¤±è´¥: ${error.message}\n`;
      }
      summary += '\n';
      
      // 4. åç«¯ API æµ‹è¯•
      summary += '4ï¸âƒ£ åç«¯ API æµ‹è¯•:\n';
      if (!token) {
        summary += `   âš ï¸ è·³è¿‡ï¼ˆæœªç™»å½•ï¼‰\n`;
      } else {
        try {
          const apiBase = document.getElementById('apiBase').value;
          const testRevealKey = revealKey || bytesToB64(crypto.getRandomValues(new Uint8Array(32)).buffer);
          
          const response = await fetch(`${apiBase}/reveal/test`, {
            headers: {
              'Authorization': `Bearer ${token}`,
              'x-reveal-key': testRevealKey,
              'Content-Type': 'application/json'
            }
          });
          
          if (response.ok) {
            const data = await response.json();
            summary += `   âœ… åç«¯ API æ­£å¸¸ (${response.status})\n`;
          } else {
            summary += `   âš ï¸ åç«¯ API å“åº”å¼‚å¸¸ (${response.status})\n`;
          }
        } catch (error) {
          summary += `   âŒ æ— æ³•è¿æ¥åç«¯: ${error.message}\n`;
        }
      }
      summary += '\n';
      
      // æ€»ç»“
      summary += '=' .repeat(60) + '\n';
      summary += 'ğŸ“ è¯Šæ–­æ€»ç»“:\n\n';
      
      if (revealKey && token && typeof crypto?.subtle !== 'undefined') {
        summary += 'âœ… ç³»ç»ŸåŸºæœ¬æ­£å¸¸\n\n';
        summary += 'å»ºè®®æ“ä½œ:\n';
        summary += '1. è¿è¡Œ"æµ‹è¯•å®Œæ•´æµç¨‹"éªŒè¯ç«¯åˆ°ç«¯åŠŸèƒ½\n';
        summary += '2. å¦‚æœæµ‹è¯•å¤±è´¥ï¼Œæ£€æŸ¥åç«¯ REDACT_MODE é…ç½®\n';
        summary += '3. æŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°æ˜¯å¦æœ‰é”™è¯¯ä¿¡æ¯\n';
      } else {
        summary += 'âš ï¸ ç³»ç»Ÿå­˜åœ¨é—®é¢˜\n\n';
        summary += 'éœ€è¦ä¿®å¤çš„é—®é¢˜:\n';
        if (!revealKey) summary += '- ç”Ÿæˆ Reveal Key\n';
        if (!token) summary += '- ç™»å½•ç³»ç»Ÿ\n';
        if (typeof crypto?.subtle === 'undefined') summary += '- ä½¿ç”¨æ”¯æŒ WebCrypto çš„æµè§ˆå™¨\n';
      }
      
      summary += '\n' + '='.repeat(60) + '\n';
      
      document.getElementById('diagnosticsSummary').textContent = summary;
    }

    // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æ£€æŸ¥å­˜å‚¨
    window.addEventListener('load', () => {
      console.log('ğŸ”§ Serdo åŠ å¯†è¯Šæ–­å·¥å…·å·²åŠ è½½');
      checkStorage();
    });
  </script>
</body>
</html>

